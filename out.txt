diff --git a/go.mod b/go.mod
index ce4f07f..4a16314 100644
--- a/go.mod
+++ b/go.mod
@@ -13,7 +13,7 @@ require (
 	github.com/hashicorp/go-hclog v1.5.0
 	github.com/hashicorp/go-multierror v1.1.1
 	github.com/hashicorp/hcl/v2 v2.19.1
-	github.com/hashicorp/hcp-sdk-go v0.92.0
+	github.com/hashicorp/hcp-sdk-go v0.96.0
 	github.com/lithammer/dedent v1.1.0
 	github.com/manifoldco/promptui v0.9.0
 	github.com/mitchellh/cli v1.1.5
diff --git a/go.sum b/go.sum
index a42c44a..58617c1 100644
--- a/go.sum
+++ b/go.sum
@@ -93,8 +93,8 @@ github.com/hashicorp/go-multierror v1.1.1 h1:H5DkEtf6CXdFp0N0Em5UCwQpXMWke8IA0+l
 github.com/hashicorp/go-multierror v1.1.1/go.mod h1:iw975J/qwKPdAO1clOe2L8331t/9/fmwbPZ6JB6eMoM=
 github.com/hashicorp/hcl/v2 v2.19.1 h1://i05Jqznmb2EXqa39Nsvyan2o5XyMowW5fnCKW5RPI=
 github.com/hashicorp/hcl/v2 v2.19.1/go.mod h1:ThLC89FV4p9MPW804KVbe/cEXoQ8NZEh+JtMeeGErHE=
-github.com/hashicorp/hcp-sdk-go v0.92.0 h1:0D429tlRozQoOjxQOSgaodNUhglhcjTg9n25vWDhkAo=
-github.com/hashicorp/hcp-sdk-go v0.92.0/go.mod h1:vQ4fzdL1AmhIAbCw+4zmFe5Hbpajj3NvRWkJoVuxmAk=
+github.com/hashicorp/hcp-sdk-go v0.96.0 h1:7oI993ZN7HG7TiFg00r2Po1N5mZZryOtSX0Ec/8cCQ4=
+github.com/hashicorp/hcp-sdk-go v0.96.0/go.mod h1:vQ4fzdL1AmhIAbCw+4zmFe5Hbpajj3NvRWkJoVuxmAk=
 github.com/huandu/xstrings v1.3.1/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
 github.com/huandu/xstrings v1.3.2 h1:L18LIDzqlW6xN2rEkpdV8+oL/IXWJ1APd+vsdYy4Wdw=
 github.com/huandu/xstrings v1.3.2/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
diff --git a/internal/commands/profile/init.go b/internal/commands/profile/init.go
index ea3969e..173c724 100644
--- a/internal/commands/profile/init.go
+++ b/internal/commands/profile/init.go
@@ -178,6 +178,7 @@ func (i *InitOpts) configureVaultSecrets() error {
 		return err
 	}
 
+	fmt.Println(listAppResp.Payload.Apps)
 	appCount := len(listAppResp.Payload.Apps)
 	if appCount <= 0 {
 		appsCreateDoc := heredoc.New(i.IO, heredoc.WithPreserveNewlines()).Must(`
diff --git a/internal/commands/vaultsecrets/secrets/displayer.go b/internal/commands/vaultsecrets/secrets/displayer.go
index 8282311..6ece4a9 100644
--- a/internal/commands/vaultsecrets/secrets/displayer.go
+++ b/internal/commands/vaultsecrets/secrets/displayer.go
@@ -4,13 +4,15 @@
 package secrets
 
 import (
+	preview_secret_models "github.com/hashicorp/hcp-sdk-go/clients/cloud-vault-secrets/preview/2023-11-28/models"
 	models "github.com/hashicorp/hcp-sdk-go/clients/cloud-vault-secrets/stable/2023-06-13/models"
 	"github.com/hashicorp/hcp/internal/pkg/format"
 )
 
 type displayer struct {
-	secrets []*models.Secrets20230613Secret
-	single  bool
+	secrets        []*models.Secrets20230613Secret
+	previewSecrets []*preview_secret_models.Secrets20231128Secret
+	single         bool
 }
 
 func newDisplayer(single bool, secrets ...*models.Secrets20230613Secret) *displayer {
@@ -20,11 +22,30 @@ func newDisplayer(single bool, secrets ...*models.Secrets20230613Secret) *displa
 	}
 }
 
+func newDisplayerPreview(single bool, secrets ...*preview_secret_models.Secrets20231128Secret) *displayer {
+	return &displayer{
+		previewSecrets: secrets,
+		single:         single,
+	}
+}
+
 func (d *displayer) DefaultFormat() format.Format {
 	return format.Table
 }
 
 func (d *displayer) Payload() any {
+	if d.previewSecrets != nil {
+		if d.single {
+			if len(d.previewSecrets) != 1 {
+				return nil
+			}
+
+			return d.previewSecrets[0]
+		}
+
+		return d.previewSecrets
+	}
+
 	if d.single {
 		if len(d.secrets) != 1 {
 			return nil
diff --git a/internal/commands/vaultsecrets/secrets/list.go b/internal/commands/vaultsecrets/secrets/list.go
new file mode 100644
index 0000000..a57d2a1
--- /dev/null
+++ b/internal/commands/vaultsecrets/secrets/list.go
@@ -0,0 +1,101 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+package secrets
+
+import (
+	"context"
+	"fmt"
+
+	preview_secret_service "github.com/hashicorp/hcp-sdk-go/clients/cloud-vault-secrets/preview/2023-11-28/client/secret_service"
+	"github.com/hashicorp/hcp-sdk-go/clients/cloud-vault-secrets/preview/2023-11-28/models"
+	"github.com/hashicorp/hcp-sdk-go/clients/cloud-vault-secrets/stable/2023-06-13/client/secret_service"
+
+	"github.com/hashicorp/hcp/internal/pkg/cmd"
+	"github.com/hashicorp/hcp/internal/pkg/format"
+	"github.com/hashicorp/hcp/internal/pkg/heredoc"
+	"github.com/hashicorp/hcp/internal/pkg/iostreams"
+	"github.com/hashicorp/hcp/internal/pkg/profile"
+)
+
+func NewCmdList(ctx *cmd.Context, runF func(*ListOpts) error) *cmd.Command {
+	opts := &ListOpts{
+		Ctx:           ctx.ShutdownCtx,
+		Profile:       ctx.Profile,
+		IO:            ctx.IO,
+		Output:        ctx.Output,
+		PreviewClient: preview_secret_service.New(ctx.HCP, nil),
+		Client:        secret_service.New(ctx.HCP, nil),
+	}
+
+	cmd := &cmd.Command{
+		Name:      "list",
+		ShortHelp: "List all active secrets.",
+		LongHelp: heredoc.New(ctx.IO).Must(`
+		The {{ template "mdCodeOrBold" "hcp vault-secrets secrets list" }} command list all active secrets under an Vault Secrets application.
+
+		Once the secrets are listed, it can be read using
+		{{ template "mdCodeOrBold" "hcp vault-secrets secrets read" }} subcommand.
+		`),
+		Examples: []cmd.Example{
+			{
+				Preamble: `List all secrets under Vault Secrets application on active profile:`,
+				Command: heredoc.New(ctx.IO, heredoc.WithPreserveNewlines()).Must(`
+				$ hcp vault-secrets secrets list
+				`),
+			},
+			{
+				Preamble: `List all secrets under the specified Vault Secrets application:`,
+				Command: heredoc.New(ctx.IO, heredoc.WithNoWrap()).Must(`
+				$ hcp vault-secrets secrets list --app-name test-app
+				`),
+			},
+		},
+		RunF: func(c *cmd.Command, args []string) error {
+			opts.AppName = appName
+
+			if runF != nil {
+				return runF(opts)
+			}
+			return listRun(opts)
+		},
+	}
+
+	return cmd
+}
+
+type ListOpts struct {
+	Ctx     context.Context
+	Profile *profile.Profile
+	IO      iostreams.IOStreams
+	Output  *format.Outputter
+
+	AppName       string
+	PreviewClient preview_secret_service.ClientService
+	Client        secret_service.ClientService
+}
+
+func listRun(opts *ListOpts) error {
+	req := preview_secret_service.NewListAppSecretsParamsWithContext(opts.Ctx)
+	req.OrganizationID = opts.Profile.OrganizationID
+	req.ProjectID = opts.Profile.ProjectID
+	req.AppName = opts.AppName
+	pageSize := int64(1)
+	req.PaginationPageSize = &pageSize
+
+	var secrets []*models.Secrets20231128Secret
+	listResp, err := opts.PreviewClient.ListAppSecrets(req, nil)
+	if err != nil {
+		return fmt.Errorf("failed to list secrets: %w", err)
+	}
+	secrets = append(secrets, listResp.Payload.Secrets...)
+	for listResp.GetPayload().Pagination.NextPageToken != "" {
+		req.PaginationNextPageToken = &listResp.Payload.Pagination.NextPageToken
+		listResp, err = opts.PreviewClient.ListAppSecrets(req, nil)
+		if err != nil {
+			return fmt.Errorf("failed to list paginated secrets: %w", err)
+		}
+		secrets = append(secrets, listResp.GetPayload().Secrets...)
+	}
+	return opts.Output.Display(newDisplayerPreview(false, secrets...))
+}
diff --git a/internal/commands/vaultsecrets/secrets/list_test.go b/internal/commands/vaultsecrets/secrets/list_test.go
new file mode 100644
index 0000000..2ef1c9f
--- /dev/null
+++ b/internal/commands/vaultsecrets/secrets/list_test.go
@@ -0,0 +1,160 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+package secrets
+
+import (
+	"context"
+	"testing"
+
+	"github.com/go-openapi/runtime/client"
+
+	"github.com/hashicorp/hcp/internal/pkg/cmd"
+	"github.com/hashicorp/hcp/internal/pkg/format"
+	"github.com/hashicorp/hcp/internal/pkg/iostreams"
+	"github.com/hashicorp/hcp/internal/pkg/profile"
+	"github.com/stretchr/testify/require"
+)
+
+func TestNewCmdList(t *testing.T) {
+	t.Parallel()
+
+	testProfile := func(t *testing.T) *profile.Profile {
+		tp := profile.TestProfile(t).SetOrgID("123").SetProjectID("456")
+		tp.VaultSecrets = &profile.VaultSecretsConf{
+			AppName: "test-app-name",
+		}
+		return tp
+	}
+
+	cases := []struct {
+		Name    string
+		Args    []string
+		Profile func(t *testing.T) *profile.Profile
+		Error   string
+		Expect  *ListOpts
+	}{
+		{
+			Name:    "Failed: No secret name arg specified",
+			Profile: testProfile,
+			Args:    []string{},
+			Error:   "ERROR: accepts 1 arg(s), received 0",
+		},
+		{
+			Name:    "Good: Secret name arg specified",
+			Profile: testProfile,
+			Args:    []string{"test"},
+			Expect: &ListOpts{
+				AppName: testProfile(t).VaultSecrets.AppName,
+			},
+		},
+	}
+
+	for _, c := range cases {
+		c := c
+		t.Run(c.Name, func(t *testing.T) {
+			t.Parallel()
+			r := require.New(t)
+
+			// Create a context.
+			io := iostreams.Test()
+			ctx := &cmd.Context{
+				IO:          io,
+				Profile:     c.Profile(t),
+				Output:      format.New(io),
+				HCP:         &client.Runtime{},
+				ShutdownCtx: context.Background(),
+			}
+
+			var gotOpts *ListOpts
+			listCmd := NewCmdList(ctx, func(o *ListOpts) error {
+				gotOpts = o
+				gotOpts.AppName = c.Profile(t).VaultSecrets.AppName
+				return nil
+			})
+			listCmd.SetIO(io)
+
+			code := listCmd.Run(c.Args)
+			if c.Error != "" {
+				r.NotZero(code)
+				r.Contains(io.Error.String(), c.Error)
+				return
+			}
+
+			r.Zero(code, io.Error.String())
+			r.NotNil(gotOpts)
+			r.Equal(c.Expect.AppName, gotOpts.AppName)
+		})
+	}
+}
+
+// func TestDeleteRun(t *testing.T) {
+// 	t.Parallel()
+
+// 	testProfile := func(t *testing.T) *profile.Profile {
+// 		tp := profile.TestProfile(t).SetOrgID("123").SetProjectID("456")
+// 		tp.VaultSecrets = &profile.VaultSecretsConf{
+// 			AppName: "test-app-name",
+// 		}
+// 		return tp
+// 	}
+
+// 	cases := []struct {
+// 		Name    string
+// 		RespErr bool
+// 		ErrMsg  string
+// 	}{
+// 		{
+// 			Name:    "Failed: Secret not found",
+// 			RespErr: true,
+// 			ErrMsg:  "[DELETE /secrets/2023-06-13/organizations/{location.organization_id}/projects/{location.project_id}/apps/{app_name}/secrets/{secret_name}][404]DeleteAppSecret default  &{Code:5 Details:[] Message:secret not found}",
+// 		},
+// 		{
+// 			Name:    "Success: Delete secret",
+// 			RespErr: false,
+// 		},
+// 	}
+
+// 	for _, c := range cases {
+// 		c := c
+// 		t.Run(c.Name, func(t *testing.T) {
+// 			t.Parallel()
+// 			r := require.New(t)
+
+// 			io := iostreams.Test()
+// 			io.ErrorTTY = true
+// 			vs := mock_secret_service.NewMockClientService(t)
+// 			opts := &DeleteOpts{
+// 				Ctx:        context.Background(),
+// 				IO:         io,
+// 				Profile:    testProfile(t),
+// 				Output:     format.New(io),
+// 				Client:     vs,
+// 				AppName:    testProfile(t).VaultSecrets.AppName,
+// 				SecretName: "test_secret",
+// 			}
+
+// 			if c.RespErr {
+// 				vs.EXPECT().DeleteAppSecret(mock.Anything, mock.Anything).Return(nil, errors.New(c.ErrMsg)).Once()
+// 			} else {
+// 				vs.EXPECT().DeleteAppSecret(&secret_service.DeleteAppSecretParams{
+// 					LocationOrganizationID: testProfile(t).OrganizationID,
+// 					LocationProjectID:      testProfile(t).ProjectID,
+// 					AppName:                testProfile(t).VaultSecrets.AppName,
+// 					SecretName:             opts.SecretName,
+// 					Context:                opts.Ctx,
+// 				}, mock.Anything).Return(&secret_service.DeleteAppSecretOK{}, nil).Once()
+// 			}
+
+// 			// Run the command
+// 			err := deleteRun(opts)
+// 			if c.ErrMsg != "" {
+// 				r.Contains(err.Error(), c.ErrMsg)
+// 				return
+// 			}
+
+// 			r.NoError(err)
+// 			r.Equal(io.Error.String(), fmt.Sprintf("✓ Successfully deleted secret with name %q\n", opts.SecretName))
+// 		})
+// 	}
+// }
diff --git a/internal/commands/vaultsecrets/secrets/secrets.go b/internal/commands/vaultsecrets/secrets/secrets.go
index 0535e4a..27d5662 100644
--- a/internal/commands/vaultsecrets/secrets/secrets.go
+++ b/internal/commands/vaultsecrets/secrets/secrets.go
@@ -44,6 +44,6 @@ func NewCmdSecrets(ctx *cmd.Context) *cmd.Command {
 	}
 
 	cmd.AddChild(NewCmdCreate(ctx, nil))
-	cmd.AddChild(NewCmdDelete(ctx, nil))
+	cmd.AddChild(NewCmdList(ctx, nil))
 	return cmd
 }
